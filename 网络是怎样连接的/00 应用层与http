00 应用层-http协议与DNS

1. http协议的消息生成过程（应用层：负责准备将要相互传递的"应用数据"）

■ 浏览器
【键入URL后】
	向服务器发起http请求
		http请求行包括：对象和动作
		对象：URI
		动作：GET/POST/PUT等
		
		请求行：GET URI HTTP版本
		消息头：向服务器提供的请求发起方的相关metadata（例如使用的浏览器种类和版本）
		消息体：向服务器发送的数据（GET时不需要添加消息体；POST时在浏览器中填写的表单数据）
		
■ 服务器
	对浏览器进行http响应
		http状态行包括：状态码和响应短语
		状态码：1xx；2xx；3xx；4xx；5xx
		响应短语：可辨识的语言（OK/NOT FOUND等）
		
		状态行：HTTP版本 状态码 响应短语
		消息头：向浏览器提供的响应发起方的相关metadata（例如服务器的类型apache；发送数据的类型text/html）
		消息体：向浏览器发送的数据（HTML文档；png图片）
		
2. 委托【操作系统】（中的解析器）向DNS服务器寻址（解析器：负责准备将要传递给DNS服务器的的"寻址消息"）

■ 委托的好处：使同样的功能可以复用（顶层的拿来主义/撒手主义）
	例如几乎所有的应用都需要发送消息，
	那么就可以‘发送消息’这一功能进行抽象并将其在操作系统的层面上实现
	其中‘操作系统层’就相当于在‘应用层’的底层

■ 在操作系统中的解析器resolver
操作系统（底层）
	协议栈/各种应用（web应用，通用应用，游戏应用）
		 > 库（通用应用程序组件集合）
		 	 > Socket库（调用网络功能的程序组件集合）
		 	 	 > 解析器（一种应用程序组件；可理解为DNS客户端；其程序名为：gethostbyname）

■ 在浏览器中调用解析器时
【浏览器的源代码】
{...
<内存地址> = gethostbyname("要查询的服务器域名(例如www.lab.glasscom.com)");
...
<发送HTTP消息>
...
}

当浏览器需要对域名DNS寻址时
调用操作系统中的解析器
进行"控制流程转移"，暂时进行工作内容的交接

■ 浏览器调用解析器后解析器的内部
【解析器的控制流程交接过程】
	 > 生成要发送给DNS服务器的"寻址消息"
		 > 调用操作系统内部的协议栈（UDP；此时控制流程会转移给协议栈）
		 	 > UDP协议通过【网卡】负责向DNS服务器发送"寻址消息"；并接受DNS服务器的"DNS响应消息"（之后控制流程交还解析器）
		 	 	 > 解析器从"DNS响应消息"中取出IP地址，将IP地址存放在<内存地址中>
		 	 	 	 > 最后控制流程交还浏览器

★ 小贴士：顺带一提，向DNS服务器发送消息时，我们当然也需要知道DNS服务器的IP地址。
   只不过这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要再去查询了

■ 浏览器再次接手控制流程后
在生成http请求时，会将储存在<内存地址>中的IP地址取出，然后把http请求和ip地址一起转交给操作系统（操作系统的协议栈负责传输）

3. DNS服务器的三大要素

■ 基本工作
接受来自客户端（由解析器发起）的【查询消息】，并根据消息内容返回【响应数据】

查询消息：域名/Class/Record Type
响应数据：A记录类型响应【IP地址】/MX记录类型响应【收件服务器】

查询消息 + 响应数据 = 储存在DNS服务器（注册表文件中）的【资源记录】

★ 小贴士：@gmail.com
   在上面的邮箱地址中，gmail.com仅仅是一个MX记录的域名
   而当查询MX记录域名时，会返回"优先级数"和"邮件服务器域名"，因为邮件服务器通常有许多个
   "优先级数"数值越小，代表其对应的邮件服务器优先级越高，
   最后再通过DNS服务器查询"邮件服务器域名"才可以知道邮件服务器的IP地址
   A记录/Address 
   MX记录/Mail eXchange
   CNAME记录/别名记录
   
■ 域的层级（略）与DNS服务器的自顶向下寻址（略）
www.baidu.com.

■ 缓存
通常自己的DNS服务器是不需要从根域DNS服务器开始依层级寻址的，因为最近一级的DNS服务器可能缓存的响应的IP地址信息
DNS服务器的响应信息会告知客户端响应结果是来自"缓存"还是来自"负责管理该域名的DNS服务器"

4. 从操作系统到协议栈（传输层入门：建立传输消息的"通道"）

■ 委托！还是委托！
【任何网络应用程序】
> 应用层想要发送数据，但是他自己只能准备数据
	 > 委托！委托！应用层对操作系统说：帮我找到目标的IP地址
	 	 > 操作系统对Socket库说，来工作了伙计，应用层想查IP，你去办吧
	 	 > Socket库对解析器说：查IP需要的"资料"一直都靠你准备，你去办吧
	 	 > 解析器准备好了DNS请求消息，对传输层说：委托！请你帮我传递消息到DNS服务器
	 	 	 > 传输层人狠话不多，带上请求消息就出发了
	 	 	 > 一转眼他就从DNS服务器带回响应消息，响应消息里面就是IP地址了，传输层把它交给解析器
	 	 > 解析器拿到了IP地址，库和操作系统给他走了个后门，这IP地址就直接到了应用层的手里

> 拿到了IP，应用层想：这下万事都具备了，准备好的【发送数据】整装待发！
	 > 委托！委托！应用层对操作系统说：帮我把数据发送到这个IP
	 	 > 操作系统对Socket库说：又来工作了，应用层要发数据到目标IP地址，你去办吧
	 	 > Socket库组织"应用程序组件"说：伙计们，这是个复杂的活儿，你们一起准备准备"数据收发时所需要的所有素材"吧
	 	 > 大哥socket："套接字素材"我准备好了！传输层老铁，委托！
	 	 	 > 传输层一看是套接字素材，二话不说，直接把数据的出入口套接字建好了
	 	 > 二哥connect：光有套接字还不行，我准备好链接服务器套接字的"管道素材"了！传输层老铁，委托！
	 	 > 二哥内心OS：管道素材还真不少，分别是【描述符】【IP地址】【端口号】
	 	 	 > 传输层一看管道素材凑齐了，二话不说，直接把连接2个套接字的管道建好了，数据可以在客户端和服务器之间进行收发了
	 	 > 大姐write：那么多的【描述符】和【发送数据】都由我来管理，我叫他们"传输素材"
	 	 > 大姐write：本次的"传输素材"，也就是特定【描述符】和应用层准备的【发送数据】我都筛选好了！传输层老铁，委托！
	 	 	 > 传输层一看，传输素材都齐了，二话不说马上动身就"带着他们从客户端去了服务器"
	 	 	 > 一眨眼，传输层就"带着服务器的响应消息回来了"
	 	 > 二姐read：我负责准备"接收素材"，也就是存放响应消息的<内存地址>，传输层老铁，委托！
	 	 > 二姐内心OS：<内存地址>也可以叫做"接收缓冲区"，接收缓冲区是位于应用程序内部的内存空间，所以可认为其位于应用层
	 	 	 > 传输层接到二姐read的委托，将响应消息交给应用层
	 	 > 小弟close：收发数据的过程由我的哥哥姐姐共同协作完成，我只需要负责切断"管道"和"套接字"就好啦
	 	 > web服务器close：发送完响应消息，就主动调用close，执行断开操作（但其实无关先后顺序，要看应用程序的构造）
	 	 > 客户端：断开操作传到客户端，客户端套接字也进入断开阶段
		 > 浏览器close：浏览器read时，发现收发数据阶段结束，则也调用close执行断开
		 
★ 小贴士：
  【描述符】是让应用程序识别套接字的机制，你想我们同时打开一堆网站，肯定要建立一堆套接字和通道
   那么到底哪个套接字是哪个通道的呢？这时候，自己的那么多套接字就靠描述符分辨了
   【IP地址】【端口号】则是让客户端和服务器之间用来识别对方套接字的机制
